{"version":3,"sources":["../../../lib/doc/defined-names.js"],"names":["_","require","colCache","CellMatrix","Range","rangeRegexp","DefinedNames","matrixMap","prototype","getMatrix","name","matrix","add","locStr","location","decodeEx","addEx","top","col","left","right","row","bottom","address","sheetName","n2l","addCellEx","remove","removeEx","removeCellEx","removeAllNames","each","forEach","callback","cell","getNames","addressStr","getNamesEx","map","findCellEx","filter","Boolean","_explore","mark","range","x","y","vGrow","yy","edge","c","findCellAt","hGrow","xx","cells","push","i","length","getRanges","ranges","$shortRange","normaliseMatrix","forEachInSheet","spliceRows","start","numDelete","numInsert","spliceColumns","model","definedName","value","rangeStr","test","split","pop","addCell","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('../utils/under-dash');\nconst colCache = require('../utils/col-cache');\nconst CellMatrix = require('../utils/cell-matrix');\nconst Range = require('./range');\n\nconst rangeRegexp = /[$](\\w+)[$](\\d+)(:[$](\\w+)[$](\\d+))?/;\n\nconst DefinedNames = function() {\n  this.matrixMap = {};\n};\n\nDefinedNames.prototype = {\n  getMatrix(name) {\n    const matrix = this.matrixMap[name] || (this.matrixMap[name] = new CellMatrix());\n    return matrix;\n  },\n\n  // add a name to a cell. locStr in the form SheetName!$col$row or SheetName!$c1$r1:$c2:$r2\n  add(locStr, name) {\n    const location = colCache.decodeEx(locStr);\n    this.addEx(location, name);\n  },\n  addEx(location, name) {\n    const matrix = this.getMatrix(name);\n    if (location.top) {\n      for (let col = location.left; col <= location.right; col++) {\n        for (let row = location.top; row <= location.bottom; row++) {\n          const address = {\n            sheetName: location.sheetName,\n            address: colCache.n2l(col) + row,\n            row,\n            col,\n          };\n\n          matrix.addCellEx(address);\n        }\n      }\n    } else {\n      matrix.addCellEx(location);\n    }\n  },\n\n  remove(locStr, name) {\n    const location = colCache.decodeEx(locStr);\n    this.removeEx(location, name);\n  },\n  removeEx(location, name) {\n    const matrix = this.getMatrix(name);\n    matrix.removeCellEx(location);\n  },\n  removeAllNames(location) {\n    _.each(this.matrixMap, matrix => {\n      matrix.removeCellEx(location);\n    });\n  },\n\n  forEach(callback) {\n    _.each(this.matrixMap, (matrix, name) => {\n      matrix.forEach(cell => {\n        callback(name, cell);\n      });\n    });\n  },\n\n  // get all the names of a cell\n  getNames(addressStr) {\n    return this.getNamesEx(colCache.decodeEx(addressStr));\n  },\n  getNamesEx(address) {\n    return _.map(this.matrixMap, (matrix, name) => matrix.findCellEx(address) && name).filter(Boolean);\n  },\n\n  _explore(matrix, cell) {\n    cell.mark = false;\n    const { sheetName } = cell;\n\n    const range = new Range(cell.row, cell.col, cell.row, cell.col, sheetName);\n    let x;\n    let y;\n\n    // grow vertical - only one col to worry about\n    function vGrow(yy, edge) {\n      const c = matrix.findCellAt(sheetName, yy, cell.col);\n      if (!c || !c.mark) {\n        return false;\n      }\n      range[edge] = yy;\n      c.mark = false;\n      return true;\n    }\n    for (y = cell.row - 1; vGrow(y, 'top'); y--);\n    for (y = cell.row + 1; vGrow(y, 'bottom'); y++);\n\n    // grow horizontal - ensure all rows can grow\n    function hGrow(xx, edge) {\n      const cells = [];\n      for (y = range.top; y <= range.bottom; y++) {\n        const c = matrix.findCellAt(sheetName, y, xx);\n        if (c && c.mark) {\n          cells.push(c);\n        } else {\n          return false;\n        }\n      }\n      range[edge] = xx;\n      for (let i = 0; i < cells.length; i++) {\n        cells[i].mark = false;\n      }\n      return true;\n    }\n    for (x = cell.col - 1; hGrow(x, 'left'); x--);\n    for (x = cell.col + 1; hGrow(x, 'right'); x++);\n\n    return range;\n  },\n\n  getRanges(name, matrix) {\n    matrix = matrix || this.matrixMap[name];\n\n    if (!matrix) {\n      return { name, ranges: [] };\n    }\n\n    // mark and sweep!\n    matrix.forEach(cell => {\n      cell.mark = true;\n    });\n    const ranges = matrix\n      .map(cell => cell.mark && this._explore(matrix, cell))\n      .filter(Boolean)\n      .map(range => range.$shortRange);\n\n    return {\n      name,\n      ranges,\n    };\n  },\n\n  normaliseMatrix(matrix, sheetName) {\n    // some of the cells might have shifted on specified sheet\n    // need to reassign rows, cols\n    matrix.forEachInSheet(sheetName, (cell, row, col) => {\n      if (cell) {\n        if (cell.row !== row || cell.col !== col) {\n          cell.row = row;\n          cell.col = col;\n          cell.address = colCache.n2l(col) + row;\n        }\n      }\n    });\n  },\n\n  spliceRows(sheetName, start, numDelete, numInsert) {\n    _.each(this.matrixMap, matrix => {\n      matrix.spliceRows(sheetName, start, numDelete, numInsert);\n      this.normaliseMatrix(matrix, sheetName);\n    });\n  },\n\n  spliceColumns(sheetName, start, numDelete, numInsert) {\n    _.each(this.matrixMap, matrix => {\n      matrix.spliceColumns(sheetName, start, numDelete, numInsert);\n      this.normaliseMatrix(matrix, sheetName);\n    });\n  },\n\n  get model() {\n    // To get names per cell - just iterate over all names finding cells if they exist\n    return _.map(this.matrixMap, (matrix, name) => this.getRanges(name, matrix)).filter(definedName => definedName.ranges.length);\n  },\n  set model(value) {\n    // value is [ { name, ranges }, ... ]\n    const matrixMap = (this.matrixMap = {});\n    value.forEach(definedName => {\n      const matrix = (matrixMap[definedName.name] = new CellMatrix());\n      definedName.ranges.forEach(rangeStr => {\n        if (rangeRegexp.test(rangeStr.split('!').pop() || '')) {\n          matrix.addCell(rangeStr);\n        }\n      });\n    });\n  },\n};\n\nmodule.exports = DefinedNames;\n"],"file":"defined-names.js"}